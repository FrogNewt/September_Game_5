#!/usr/bin/env python3

import arcade
import numpy
from pygame import mixer
import arcade.text as text
import sim_for_game as sim
import time

# A list of individuals generated by the simulation
pop = sim.starter_list

# A 'population' objected that holds important values generated by simulation
pop_keeper = sim.pop_holder

# Gives the beginning mean upon which the pokemon will be based
starting_mean = pop_keeper.mean_phenotypic_trait_value_list[0]

# Constants for scaling the images used for the pokemon
bulbasaur_scaling = 0.01
charmander_scaling = 0.01
squirtle_scaling = 0.02

# Creates a dictionary to easily access the scale values
scale_dict = {
	"bulbasaur" : bulbasaur_scaling,
	"charmander" : charmander_scaling,
	"squirtle" : squirtle_scaling

}

# Sets a scalar constant for variance (otherwise, characters get too big/small)
var_scalar = 0.01

# Constants for screen
SCREEN_WIDTH = 1500
SCREEN_HEIGHT = 1200
SCREEN_TITLE = "Jake's Platformer"

# Set default textures
TEXTURE_RIGHT = 1
TEXTURE_LEFT = 0



# Constants used to scale stationary objects
CLOUD_SCALING = 0.05
MOUNTAIN_SCALING = 0.5
BOUNDARY_TREE_SCALING = 0.40


TILE_SCALING = 0.5
GYARADOS_SCALING = 0.1

# Set the speed at which the character increments
ORGANISM_MEAN_MOVEMENT_SPEED = 20
ENEMY_MOVEMENT_SPEED = 1

# Controls how fast the character returns to the ground after jumping or "flying" (i.e. traveling upward at a rate)
GRAVITY = 1.0



# How many pixels to keep as a minimum margin between the character
# and the edge of the screen

# 6/8 is used for my Mac OS X, but it may need to be adjusted for Windows or Linux
LEFT_VIEWPORT_MARGIN = SCREEN_WIDTH*(6/8)
RIGHT_VIEWPORT_MARGIN = SCREEN_WIDTH*(6/8)
BOTTOM_VIEWPORT_MARGIN = 100
TOP_VIEWPORT_MARGIN = 350


class MyGame(arcade.Window):
	"""
	Main application class.
	"""

	def __init__(self):

		# Call the parent class and set up the window
		super().__init__(SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_TITLE)

		# These are lists that keep track of all sprites--every sprite should have a list, 
		# and that listed should probably be based on what the sprite can/can't do

		self.wall_list = None
		self.player_list = None
		self.darwin_list = None
		self.enemy_list = None
		self.starters_list = None

		# A series of switches that allow for transition between phases at the beginning
		# of the game
		self.pre_intro_1_started = False
		self.pre_intro_2_started = False

		# Initializes character scaling; this will be a number multiplied by a constant and the mean/variance/std_dev
		self.CHARACTER_SCALING = ""

		# This variable doesn't need to be called; it just serves to initalize the mixer by existing
		self.initialize_mixer = mixer.init()

		# Imports music tracks to be used at different points in the game
		self.intro_music = 'sounds/fairy_fountain_intro.wav'
		self.game_music = 'sounds/Night_Riding.wav'
		self.love_music = 'sounds/love.wav'

		# Represents whichever song is currently playing; default is introductory fairy-fountain music
		self.current_music = mixer.music.load(self.intro_music)

		# The pokemon that scroll through the opening screen above "Quantitative Genetics of Pokemon"
		self.intro_pokemon = None
		self.intro_venusaur = None
		self.intro_charizard = None
		self.intro_gyarados = None

		# Holds a sprite that carries the "Jake Botello presents" at the intro
		self.jake = None

		# Holds AN enemy sprite that can be used for debugging
		self.enemy = None

		# Holds the "darwin" sprite rendered for dialogue and (sometimes, possibly) the flag at the end of the level
		self.darwin_sprite = None

		# Sets the current state of the game; defaults to "PREOPENING", which walks through Jake presents, Warlak production, etc
		self.current_state = "PREOPENING"

		# Offers up the images to be used for the starter pokemon based on the user's choice
		self.starter_organism_dict = {
		"bulbasaur" : "images/bulbasaur_left.png",
		    "charmander" : "images/charmander_left.png",
		    "squirtle" : "images/squirtle_left.png"

		}

		# Holds the starting organism; charizard is by default to show (for debugging) when things aren't working
		self.starter_organism = "images/player_1/clean_charizard.png"

		# Used to recognize the starting pokemon chosen by the user
		self.starter_string = ""


		# Attributes used to keep track of which organism is being followed on the screen
		self.focal_organism = ""

		# A list that keeps track of all pokemon available to become focal organisms
		self.focal_organism_list = []

		# The current level
		self.level = 1

		# Sets the background screen fade
		self.fade_stage_1 = False
		self.fade_stage_2 = False
		self.fade_stage_3 = False
		self.fade_stage_4 = False
		self.fade_stage_5 = False
		self.fade_stage_6 = False
		self.fade_stage_7 = False
		self.fade_stage_8 = False
		self.fade_stage_9 = False
		self.fade_stage_10 = False
		self.fade_stage_11 = False
		self.quick_sunset = False

		# Sets the default values of these colors to be changed
		self.fade_blue = 238
		self.fade_green = 149
		self.fade_red = 100

		# Sets up a floor for the histogram characters; ### CHANGE THIS NAME ###
		self.hist_floor = ""

		# Checks to see if the level is complete
		self.level_complete = False

		# Lets us know we're ready to go to the next level
		self.go_to_next_level = False

		# Switches on while histogram is being generated
		self.making_histogram = False

		# If this is true, begin the debriefing process
		self.debriefing = False

		# Switches extinction on and ends the game
		self.extinction = False

		# Used in analog sunset method; holds the start time to be compared to the current time
		self.start_time = ""

		# Toggles the breeding event on/off
		self.ready_to_breed = False

		# Used to keep track of our scrolling
		self.view_bottom = 0
		self.view_left = 0

		 # Sets the background color--there are lots of options available through the arcade site
		arcade.set_background_color((230, 143, 255))

############################# INIT METHOD HAS BEEN CLEANED #############################


	def setup(self, level=1, CHARACTER_SCALING = starting_mean):
		""" Set up the game here. Call this function to restart the game. """

		######### RELATED TO SCREEN CREATION ##############

		# Used to keep track of our scrolling
		self.view_bottom = 0
		self.view_left = 0

		# Designate the "floor" for the histogram characters ###### CHANGE NAME #########
		self.hist_floor = 70

		# Represents the end of the level--Darwin/a flag goes here!
		self.end_of_level = 1200



		######## REDEFINE ALL IMPORTANT LISTS AS SPRITELISTS #######

		# Note: SpriteList class instances have properties different from normal lists, e.g. no indexes

		# Create the Sprite lists
		self.player_list = arcade.SpriteList()
		self.wall_list = arcade.SpriteList()
		self.enemy_wall_list = arcade.SpriteList()
		self.enemy_list = arcade.SpriteList()
		self.darwin_list = arcade.SpriteList()

		# A standard list to hold all potential organisms in focus
		self.focal_organism_list = []

		# A standard list ot hold all enemy physics engines
		self.enemy_physics_engine_list = []


		######### RELATED TO ENVIRONMENT CREATION ##########

		### DRAW THE GROUND ###
		for x in range(-500, 10000, 64):
			# Chooses an image to load as the "floor"
			##### CHANGE THIS BASED ON USER INPUT #####
			wall = arcade.Sprite("images/tiles/grassMid.png", TILE_SCALING)

			# Continues drawing this image over and over at intervals of '64'...
			# ...for the duration of this for loop (currently set at 10,000 as an x-distance to travel)
			wall.center_x = x

			# Sets the center of the image at height '10'
			wall.center_y = 10

			# Makes the floor a part of "wall_list", which interacts with players via gravity/physics, etc
			self.wall_list.append(wall)

			# Be sure this also gets added to enemy wall list, which may have different rules than the player walls
			self.enemy_wall_list.append(wall)


		### DRAW THE SKY ###
		for x in range(-500, 10000, 64):
		# Sets the sky as clouds ### LET USER INPUT CHANGE THIS ###
			wall = arcade.Sprite("images/tiles/cloud.png", CLOUD_SCALING)

			# Same rules apply as for ground; goes on indefinitely based on x-argument (10,000, here)
			wall.center_x = x

			# Starts around the top of the viewport for the user
			wall.center_y = 510

			# This is relevant for the player, so it's on wall_list
			self.wall_list.append(wall)

			# This is relevant for the enemy, so it's on enemy_wall_list
			self.enemy_wall_list.append(wall)

		### BOUNDARY LEFT IMAGE ####
		# Makes a giant 'boundary tree' that prevents characters from walking (left) off the face of the Earth
		tree = arcade.Sprite("images/tiles/boundary_tree.png", BOUNDARY_TREE_SCALING)

		# Sets this tree at -350 = x and 265 = y (about the height of the 'sky'/clouds/forest trees)
		tree.center_x = -350
		tree.center_y = 265

		# This tree is only relevant to players (it doesn't affect enemies), so we'll only append...
		# ...it to wall list
		self.wall_list.append(tree)


		### SET UP MOUNTAIN ###

		# This sets up a mountain as a climbing obstacle if smaller organisms are being (deliberately)...
		# ...given a hard time
		mountain = arcade.Sprite("images/mountain.png", MOUNTAIN_SCALING)

		# Gives the mountain coordinates based on random generation
		mountain.center_x = numpy.random.randint(200, 500)
		mountain.center_y = numpy.random.randint(150, 300)

		# Adds the mountain to the wall lists (it's treated as a wall in physics engines)
		self.wall_list.append(mountain)
		self.enemy_wall_list.append(mountain)


		### SET UP ROCKS/OBSTACLES ###

		# Minimum x/y coordinates for rocks/obstacles
		rock_range_min = [200, self.hist_floor+40]

		# Maximum x/y coordinates for rocks/obstacles
		rock_range_max = [1000, self.hist_floor + 50]

		# Makes however many rocks you want (range)
		for coordinate in range(10):

			# Uses numpy to randomly generated coordinates within the min/max shown above
			x_coordinate = numpy.random.randint(rock_range_min[0], rock_range_max[0]) 
			y_coordinate = numpy.random.randint(rock_range_min[1], rock_range_max[1])

			# Makes it an object to append to the wall_list
			rock = arcade.Sprite("images/rock.png", TILE_SCALING)

			# Gets a position randomly assigned above
			rock.position = [x_coordinate, y_coordinate]

			# Adds to the wall lists (player and enemy, respectively)
			self.wall_list.append(rock)
			self.enemy_wall_list.append(rock)


		# This is the minimum height of an object generated above the ground
		# This should scale to a certain member of the population
		# It's at 150 now but should change!
		level_y_boundary = 150

		# This adds it to the floor so that it includes the ground in the calculation
		level_y_boundary = level_y_boundary + self.hist_floor





		######### RELATED TO INTRODUCTORY PHASES ###########

		# Holds 'Jake Presents' message
		self.jake = arcade.Sprite("images/jakepresents.png", scale=0.5)

		# Stays on while Jake has not fully faded-in
		self.jake.fading_in = True

		# Demonstrates that Jake is totally faded-in (### CAN BE SUBSTITUTED FOR JAKE FADE_COUNT 
		# IN PREVIOUS ITERATION ###)
		self.jake.faded = False

		# Holds the texture that allows "Jake" to transform into the warlak image
		# for the second introductory page
		self.jake.textures = []

		# Load the warlak texture for use
		texture = arcade.load_texture("images/warlak3.png", scale=0.5)

		# Add warlak texture to texture list
		self.jake.textures.append(texture)

		# The "Quantitative Genetics of Pokemon" Banner-Sprite
		self.qg_pokemon = arcade.Sprite("images/qg_pokemon.png", scale = 0.5)

		# Switch for drawing opening screen
		self.pre_2_ready = False

		# Switch for beginning game
		self.start_game = False


		# Holds all the pokemon rotated through in introductory screen
		self.intro_pokemon = []
		# Loads pokemon used in introductory screen
		self.intro_gyarados = arcade.Sprite("images/intro_pokemon/gyarados_left.png", scale = 0.4)
		self.intro_charizard = arcade.Sprite("images/intro_pokemon/clean_charizard.png", scale = 0.4)
		self.intro_venusaur = arcade.Sprite("images/intro_pokemon/venusaur.png", scale = 0.25)

		# Appends pokemon to introductory list
		self.intro_pokemon.append(self.intro_venusaur)
		self.intro_pokemon.append(self.intro_charizard)
		self.intro_pokemon.append(self.intro_gyarados)

		# Adds attributes to intro pokemon to allow them to fade in/out
		for i in self.intro_pokemon:
			i.fading_in = True
			i.fading_out = False



		############# OAK AND DARWIN DIALOGUE PHASES ################

		# Music played while Professor Oak and Darwin are speaking in the greeting
		self.pokemon_medley = "sounds/pokemon_medley.wav"

		# Creates a Darwin sprite--he currently doubles as a speaker AND the end of the level (CHANGE)
		self.darwin_sprite = arcade.Sprite("images/darwin.png")

		# Path of the sound Darwin plays when he enters (annoyed)
		self.darwin_sprite.sound_effect_annoyed = "sounds/darwin_annoyed.wav"

		# Load the sound Darwin plays when he enters
		self.darwin_annoyed_sound = arcade.load_sound(self.darwin_sprite.sound_effect_annoyed)

		# A switch to determine whether or not this sound has been played so it doesn't play infinitely
		self.darwin_sound_1_played = False




		# Darwin Textures
		self.darwin_sprite.textures = []

		# Darwin facing right
		texture = arcade.load_texture("images/darwin.png", scale = 1)
		# Appended to list
		self.darwin_sprite.textures.append(texture)

		# Darwin facing left
		texture = arcade.load_texture("images/darwin.png", mirrored = True, scale = 1)

		# Appended to list
		self.darwin_sprite.textures.append(texture)

		# Sets Darwin to be facing left by default
		self.darwin_sprite.set_texture(1)

		# Sets Darwin up at the end of the level (currently 1200)
		self.darwin_sprite.center_x = self.end_of_level

		# Keeps Darwin on the ground
		self.darwin_sprite.center_y = 64

		# Appends Darwin to a list with himself in it (useful for checking collisions)
		self.darwin_list.append(self.darwin_sprite)


		# Loads the image of Professor Oak
		self.prof_oak = arcade.Sprite("images/prof_oak.png", 1)

		# A switch that says Professor Oak is speaking #### MAY BE DEPRECATED #####
		self.prof_oak_dialogue = False

		# A switch that says Darwin is speaking #### MAY BE DEPRECATED #####
		self.darwin_dialogue = False

		# If Professor Oak needs to respond to a button (or something else in the phase does)...
		# ...these keys keep track
		self.prof_oak_key_pressed_1 = False
		self.prof_oak_key_pressed_2 = False
		self.prof_oak_key_pressed_3 = False
		self.prof_oak_key_pressed_4 = False


		###### FIRST OAK AND DARWIN DIALOGUE EVENT (WELCOME/INTRODUCTIONS) ########

		# First set of dialogue images (9/9; numbers 4, 5, 7, and 8 are Darwin)
		self.oak1_m1_of_9 = arcade.Sprite("images/oak1/oak1-1.png")
		self.oak1_m2_of_9 = arcade.Sprite("images/oak1/oak1-2.png")
		self.oak1_m3_of_9 = arcade.Sprite("images/oak1/oak1-3.png")

		self.darwin1_m4_of_9 = arcade.Sprite("images/oak1/oak1-4.png")
		self.darwin1_m5_of_9 = arcade.Sprite("images/oak1/oak1-5.png")

		self.oak1_m6_of_9 = arcade.Sprite("images/oak1/oak1-6.png")

		self.darwin1_m7_of_9 = arcade.Sprite("images/oak1/oak1-7(revised).png")
		self.darwin1_m8_of_9 = arcade.Sprite("images/oak1/oak1-8.png")

		self.oak1_m9_of_9 = arcade.Sprite("images/oak1/oak1-9.png")




		# Creates a list to hold the first of Oak/Darwin's musings
		self.oak1_list = []

		# Appends images to list
		self.oak1_list.append(self.oak1_m1_of_9)
		self.oak1_list.append(self.oak1_m2_of_9)
		self.oak1_list.append(self.oak1_m3_of_9)
		self.oak1_list.append(self.darwin1_m4_of_9)
		self.oak1_list.append(self.darwin1_m5_of_9)
		self.oak1_list.append(self.oak1_m6_of_9)
		self.oak1_list.append(self.darwin1_m7_of_9)
		self.oak1_list.append(self.darwin1_m8_of_9)
		self.oak1_list.append(self.oak1_m9_of_9)


		###### SECOND OAK AND DARWIN DIALOGUE EVENT (SELECT A SPECIES) ########


		# Second set of dialogue images (5/5; 2 is Darwin, #5 has three options based on choice)
		self.oak2_m1_of_5 = arcade.Sprite("images/oak2/oak2-1.png")

		self.darwin2_m2_of_5 = arcade.Sprite("images/oak2/oak2-2.png")

		self.oak2_m3_of_5 = arcade.Sprite("images/oak2/oak2-3.png")
		self.oak2_m4_of_5 = arcade.Sprite("images/oak2/oak2-4.png")

		# Choose your starter pokemon and oak will respond appropriately
		self.oak2_m5charmander_of_5 = arcade.Sprite("images/oak2/oak2-5(charmander).png")
		self.oak2_m5squirtle_of_5 = arcade.Sprite("images/oak2/oak2-5(squirtle).png")
		self.oak2_m5bulbasaur_of_5 = arcade.Sprite("images/oak2/oak2-5(bulbasaur).png")

		# Makes the list to hold dialogue
		self.oak2_list = []

		# Appends images (messages) to list
		self.oak2_list.append(self.oak2_m1_of_5)
		self.oak2_list.append(self.darwin2_m2_of_5)
		self.oak2_list.append(self.oak2_m3_of_5)
		self.oak2_list.append(self.oak2_m4_of_5)
		self.oak2_list.append(self.oak2_m5charmander_of_5)
		self.oak2_list.append(self.oak2_m5squirtle_of_5)
		self.oak2_list.append(self.oak2_m5bulbasaur_of_5)


		###### THIRD OAK AND DARWIN DIALOGUE EVENT (SELECT A HISTOGRAM COLUMN) ########

		# Third set of dialogue images (6/6; #5 is Darwin)
		self.oak3_m1_of_6 = arcade.Sprite("images/oak3/oak3-1.png")
		self.oak3_m2_of_6 = arcade.Sprite("images/oak3/oak3-2.png")
		self.oak3_m3_of_6 = arcade.Sprite("images/oak3/oak3-3.png")
		self.oak3_m4_of_6 = arcade.Sprite("images/oak3/oak3-4.png")
		self.darwin3_m5_of_6 = arcade.Sprite("images/oak3/oak3-5.png")
		self.oak3_m6_of_6 = arcade.Sprite("images/oak3/oak3-6.png")

		# Makes a list to hold all dialogue images
		self.oak3_list = []

		# Appends all dialogue images to the list
		self.oak3_list.append(self.oak3_m1_of_6)
		self.oak3_list.append(self.oak3_m2_of_6)
		self.oak3_list.append(self.oak3_m3_of_6)
		self.oak3_list.append(self.oak3_m4_of_6)
		self.oak3_list.append(self.darwin3_m5_of_6)
		self.oak3_list.append(self.oak3_m6_of_6)



		###### FOURTH OAK AND DARWIN DIALOGUE EVENT ########

		# Creates a list to hold the fourth dialogue event's images
		self.oak4_list = []



		###### MASTER LIST OF ALL OAK/DARWIN DIALOGUE ########

		# This list contains all dialogue so that it can be easily modified at once
		# (i.e. through a for-loop)
		self.dialogue_master_list = []

		# Extends (rather than appending) each new list to make one gigantic, SINGLE list of dialogue messages
		self.dialogue_master_list.extend(self.oak1_list)
		self.dialogue_master_list.extend(self.oak2_list)
		self.dialogue_master_list.extend(self.oak3_list)
		self.dialogue_master_list.extend(self.oak4_list)

		# Applies effects to all messages at once
		for i in self.dialogue_master_list:
			# Starts every message out with a "fade-in"
			i.fading_in = True

			# This switch tells us when the message is ready to start losing opacity
			i.fading_out = False

			# Sets the scale of each message (this should be fixed at 0.4)
			i.scale = 0.4





###### BIOLOGICAL/QUANTITATIVE VALUES #####

		# The variance of the current generation
		self.var = pop_keeper.additive_genetic_variance_list[self.level-1]

		# The standard deviation of the current generation (square root of variance)
		self.std_dev = numpy.sqrt(self.var)

		############# DELETE IF NOT NECESSARY ###########
		#self.update_scaling(self.starter_string)

		# A switch used to make sure scaling is only updated ONCE...
		# ...and not with each update()
		self.scaling_updated = False

		# Checks to see if the effect of selection has been calculated this generation
		self.selection_calculated = False


		##### RELATED TO BREEDING EVENT ########

		# Creates a list to hold the hearts that'll go floating everywhere during random mating
		self.heart_list = arcade.SpriteList()

		# A switch--tells us whether or not we're reading for the "fly-away" event/random mating
		self.honeymoon_ready = False


		# Generates all the little hearts that go swelling everywhere on the screen (50 now, but adjustable)
		for i in range(50):
			# Chooses an image for the hearts (modify by level, maybe?)
			heart = arcade.Sprite("images/heart.png", scale = 0.01)

			# Check to see the heart has been given a coordinate; by default, it hasn't
			heart.has_point = False

			# Check to see if the heart has already begun the process of swelling/shrinking
			# By default, it hasn't
			heart.growing = False

			# Add to the list of hearts
			self.heart_list.append(heart)


		# Check to see how many organisms have found a pair/match; starts at zero and increments up
		self.paired_count = 0

		# Holds the list of coordinates that organisms will occupy once they're ready for mating
		self.breeding_coordinates = []

		# Coordinates that've already been used by organisms--these should be getting moved over...
		# ...from "breeding coordinates"
		# You should be able to check to see that only coordinates that AREN'T in this list are...
		# ...getting picked by new organisms.
		self.used_coords = []






		#### EXPERIMENTAL: TRYING TO CREATE TEN DIFFERENT VARIANTS ACROSS A GRADIENT ####

		# Define an 'experimental' list (#### CHANGE NAME ####)
		self.experimental_list = arcade.SpriteList()

		# Defines all sprites #### (PROBABLY SOULD REMOVE) ####
		self.define_all_ten_sprites_images()


		########## RELATED TO ENEMY CONSTRUCTION ##############


		# Set up the predator's image and scaling
		self.enemy = arcade.Sprite("images/red_gyarados_right.png", GYARADOS_SCALING)

		# Sets the starting position of the enemy well-behind the player's starting position
		self.enemy.center_x = -150

		# Sets the enemy down on the ground
		self.enemy.center_y = 90

		##### MAKE ENEMIES ON A SCHEDULE; NEEDS WORK!!!!! #######
		#arcade.schedule(self.make_enemy, 5)

		# Adds the main enemy generated to the enemy_list
		self.enemy_list.append(self.enemy)




		#################### CREATE PHYSICS ENGINES ####################

		# Creates a physics engine list to hold all player engines
		self.player_physics_engines_list = []

		# Create a physics engine for each sprite in the player_list
		for i in self.experimental_list:

			# Creates the physics engine
			i.physics_engine = arcade.PhysicsEnginePlatformer(i, self.wall_list ,GRAVITY)
			# Adds to the list
			self.player_physics_engines_list.append(i.physics_engine)

		# Creates a physics engine for a single enemy (if there's just one)
		self.physics_engine_enemy = arcade.PhysicsEnginePlatformer(self.enemy, self.enemy_wall_list, GRAVITY)

		# Adds the single-enemy physics-engine to the enemy physics-engine list
		self.enemy_physics_engine_list.append(self.physics_engine_enemy)

		# Gives Darwin a physics engine so that he can serve as the end of the level
		self.physics_engine_darwin = arcade.PhysicsEnginePlatformer(self.darwin_sprite, self.wall_list, GRAVITY)




		############################# SETUP METHOD HAS BEEN CLEANED #############################


	def define_all_ten_sprites_images(self):


			### Generates a sprite for each level of variation in the population ###

			# Will lose 2 std_dev from mean
	        self.organism_var1_sprite = arcade.Sprite(self.starter_organism)

	        # Will lose 1.5 std_dev from mean
	        self.organism_var2_sprite = arcade.Sprite(self.starter_organism)

	        # Will lose 1 std_dev from mean
	        self.organism_var3_sprite = arcade.Sprite(self.starter_organism)

	        # Will lose 0.5 std_dev from mean
	        self.organism_var4_sprite = arcade.Sprite(self.starter_organism)

	        # Will lose 0.25 std_dev from mean
	        self.organism_var5_sprite = arcade.Sprite(self.starter_organism)

	        # Will gain 0.25 std_dev from mean
	        self.organism_var6_sprite = arcade.Sprite(self.starter_organism)

	        # Will gain 0.5 std_dev from mean
	        self.organism_var7_sprite = arcade.Sprite(self.starter_organism)

	        # Will gain 1 std_dev from mean
	        self.organism_var8_sprite = arcade.Sprite(self.starter_organism)

	        # Will gain 1.5 std_dev from mean
	        self.organism_var9_sprite = arcade.Sprite(self.starter_organism)

	        # Will gain 2 std_dev from mean
	        self.organism_var10_sprite = arcade.Sprite(self.starter_organism)

	        # Append all to experimental list
	        self.experimental_list.append(self.organism_var1_sprite)
	        self.experimental_list.append(self.organism_var2_sprite)
	        self.experimental_list.append(self.organism_var3_sprite)
	        self.experimental_list.append(self.organism_var4_sprite)
	        self.experimental_list.append(self.organism_var5_sprite)
	        self.experimental_list.append(self.organism_var6_sprite)
	        self.experimental_list.append(self.organism_var7_sprite)
	        self.experimental_list.append(self.organism_var8_sprite)
	        self.experimental_list.append(self.organism_var9_sprite)
	        self.experimental_list.append(self.organism_var10_sprite)

	        # Check to see which starter was chosen and change textures
	        for i in self.experimental_list:

	            # If starter is bulbasaur, give bulbasaur textures
	            if self.starter_string == "bulbasaur":
	            	# Append left image
	                texture = arcade.load_texture("images/bulbasaur_left.png")
	                i.textures.append(texture)

	                # Append right image
	                texture = arcade.load_texture("images/bulbasaur_right.png")
	                i.textures.append(texture)
	                print("We're bulbasaurs with our textures appended!")

	            # If starter is charmander, give charmander textures
	            elif self.starter_string == "charmander":
	            	# Append left image
	                texture = arcade.load_texture("images/charmander_left.png")
	                i.textures.append(texture)

	                # Append right image
	                texture = arcade.load_texture("images/charmander_right.png")
	                i.textures.append(texture)
	                print("We're charmanders with our textures appended!")
	            
	            # If starter is squirtle, give squirtle textures
	            elif self.starter_string == "squirtle":
	            	# Append left image
	                texture = arcade.load_texture("images/squirtle_left.png")
	                i.textures.append(texture)

	                # Append right image
	                texture = arcade.load_texture("images/squirtle_right.png")
	                i.textures.append(texture)
	                print("We're squirtles with our textures appended!")

	            
	           
	            # Establishes that the organism, by default, isn't dead
	            i.dead = False


############## DEFINE_ALL_TEN_SPRITES METHOD HAS BEEN CLEANED #############

	# Set everyone to their proper scalar values; note that this won't run properly
	# until a starter has been selected
	def scale_everyone(self):

		if self.starter_string:
			
			# Establish which type of scaling is appropriate by checking the starter string...
			# ...and retrieving the right scale
			appropriate_mean_scale = scale_dict[self.starter_string]

			# Set character scaling equal to the mean times the scalar constant
			self.CHARACTER_SCALING = appropriate_scale * starting_mean

			# Prevents the variance from making characters overtake the screen
			self.var = self.var * var_scalar

			# Set the standard deviation equal to the square root of the variance
			self.std_dev = numpy.sqrt(self.var)

			# Give each character its appropriate amount of deviation from the mean
			self.organism_var1_sprite.scale = self.CHARACTER_SCALING - (self.std_dev*2)
			self.organism_var2_sprite.scale = self.CHARACTER_SCALING - (self.std_dev*1.5)
			self.organism_var3_sprite.scale = self.CHARACTER_SCALING - (self.std_dev)
			self.organism_var4_sprite.scale = self.CHARACTER_SCALING - (self.std_dev*0.5)
			self.organism_var5_sprite.scale = self.CHARACTER_SCALING - (self.std_dev*0.25)
			self.organism_var6_sprite.scale = self.CHARACTER_SCALING + (self.std_dev*0.25)
			self.organism_var7_sprite.scale = self.CHARACTER_SCALING + (self.std_dev*0.5)
			self.organism_var8_sprite.scale = self.CHARACTER_SCALING + (self.std_dev*1)
			self.organism_var9_sprite.scale = self.CHARACTER_SCALING + (self.std_dev*1.5)
			self.organism_var10_sprite.scale = self.CHARACTER_SCALING + (self.std_dev*2)

	        # Sets all textures in each organism equal to the scale of the organism
			for org in self.experimental_list:
				for texture in org.textures:
					texture.scale = org.scale
	        
	        # If the scale goes below zero, change it to something teensy but positive
			for i in range(len(self.experimental_list)-1):
				if self.experimental_list[i].scale <= 0:
					self.experimental_list[i].scale = 0.000000001
				print("Scale for var ", i+1,":", self.experimental_list[i].scale)

############## SCALE EVERYONE METHOD HAS BEEN CLEANED #############
    
########################### METHODS RELATED TO FADING IN AND OUT ##################################


	# A "fade-in-and-out" method; ### CHANGE NAME ONCE EVERYTHING'S WORKING ###
	def fade_in_and_out_better(self, target, rate_in=1, rate_out=1):
		# If the target isn't already fading-out AND is completely transparent:
		if not ((target.fading_out == True) and (target.alpha == 0)):
			# If the target IS still fading in but is completely opaque
			# (i.e. the target hasn't begun yet):
			if (target.fading_in == True) and (target.alpha == 255):
				# Change its opacity to zero so that it can begin the process
			    target.alpha = 0

			# If the target's opacity is zero and it's fading in, starting increasing opacity
			if target.fading_in == True:
			    target.alpha += rate_in

			# If the target is still fading in and the opacity is over 240, start fading out
			if (target.fading_in == True) and target.alpha > 240:
			    target.fading_in = False
			    target.fading_out = True

			# If the target is fading out but still has some opacity (>0), reduce opacity
			if (target.fading_out == True) and (target.alpha > 0):
			    target.alpha -= rate_out

			# If the target is fading out and its opacity has fallen to or below zero, keep it at zero
			elif (target.fading_out == True) and (target.alpha <= 0):
			    target.alpha = 0

			# Only draw the target when its opacity is greater than zero (to save on memory) 
			if target.alpha > 0:
			    target.draw()




################# FADE IN AND OUT BETTER METHOD HAS BEEN CLEANED ##############




	def fade_in_sequence(self, target_list, start_range, end_range, rate_in=1, rate_out=1, lower_threshold=100, upper_threshold=255):
		# Start by fading in-and-out the first thing in the list
		# If the start range is zero, just begin with zero
		if start_range == 0:
			self.fade_in_and_out_better(target_list[0], rate_in, rate_out)

		# If the start range is greater than zero, start one before the beginning of the start range
		elif start_range > 0:
			self.fade_in_and_out_better(target_list[start_range-1], rate_in, rate_out)

		# For everything from the start range to the end range:
		for i in range(len(target_list[start_range:end_range])):

			# If the target isn't already at zero opacity and it IS still fading out:
			if not ((target_list[i].alpha == 0) and (target_list[i].fading_out == True)):

				# If the PREVIOUS target is now below the upper threshold of opacity and is fading out:
				if (target_list[i-1].alpha < upper_threshold) and (target_list[i-1].fading_out == True):

					# Begin fading out the target
					self.fade_in_and_out_better(target_list[i], rate_in, rate_out)
				
				# If the target is fading out OR its opacity is not at full, begin the process
				elif (target_list[i].fading_out == True) or (target_list[i].alpha != 255):
					self.fade_in_and_out_better(target_list[i], rate_in, rate_out)


############################## METHODS RELATED TO DRAWING DIALOGUE CHARACTERS ##########################

	def draw_charles_darwin(self):
		# Get the current viewport
		starting_viewport = arcade.get_viewport()

		# Set darwin equal to his standard (default) texture (which is to the left)
		self.darwin_sprite.set_texture(0)

		# Set Darwin's coordinates on the screen (top left corner of the viewport)
		self.darwin_sprite.center_x = starting_viewport[0] + 100
		self.darwin_sprite.center_y = starting_viewport[2] + 500

		# Draw Darwin
		self.darwin_sprite.draw()




	def on_draw(self):
		self.draw_charles_darwin()

# Main method of the game; calls set-up initially 
# Call set-up again to run another level
def main():
    """ Main method """
    window = MyGame()
    print("initialized!")
    window.setup(window.level)
    print("Just ran setup!")
    arcade.run()


# Calls method to run the game/page
if __name__ == "__main__":
    main()
